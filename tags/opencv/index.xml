<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Opencv on ÂïäÔºåÂìàÔºÅ</title><link>https://lartpang.github.io/blog/tags/opencv/</link><description>Recent content in Opencv on ÂïäÔºåÂìàÔºÅ</description><generator>Hugo -- 0.145.0</generator><language>en-us</language><lastBuildDate>Mon, 25 Mar 2024 09:41:52 +0000</lastBuildDate><atom:link href="https://lartpang.github.io/blog/tags/opencv/index.xml" rel="self" type="application/rss+xml"/><item><title>Six methods of indexing pixels of Mat in OpenCV</title><link>https://lartpang.github.io/blog/posts/0021-six-methods-of-indexing-pixels-of-mat-in-opencv/</link><pubDate>Mon, 25 Mar 2024 09:41:52 +0000</pubDate><guid>https://lartpang.github.io/blog/posts/0021-six-methods-of-indexing-pixels-of-mat-in-opencv/</guid><description> Six methods of indexing pixels of Mat in OpenCV .at&lt;>() // modify the pixel directly for (int h = 0; h &lt; image.rows; ++h) { for (int w = 0; w &lt; image.cols; ++w) { image.at&lt;Vec3b>(h, w)[0] = 255; image.at&lt;Vec3b>(h, w)[1] = 0; image.at&lt;Vec3b>(h, w)[2] = 0; } } // modify the pixel by the reference for (int h = 0; h &lt; image.rows; ++h) { for (int w = 0; w &lt; image.cols; ++w) { Vec3b&amp; bgr = image.at&lt;Vec3b>(h, w); bgr.val[0] = 0; bgr.val[1] = 255; bgr.val[2] = 0; } } // the image has one channel for (int h = 0; h &lt; image.rows; ++h) { for (int w = 0; w &lt; image.cols / 2; ++w) { image.at&lt;uchar>(h, w) = 128; } } .ptr&lt;>() // use uchar type for (int h = 0; h &lt; image.rows; ++h) { for (int w = 0; w &lt; image.cols / 2; ++w) { uchar* ptr = image.ptr&lt;uchar>(h, w); ptr[0] = 255; ptr[1] = 0; ptr[2] = 0; } } // use cv::Vec3b type for (int h = 0; h &lt; image.rows; ++h) { for (int w = 0; w &lt; image.cols / 2; ++w) { Vec3b* ptr = image.ptr&lt;Vec3b>(h, w); ptr->val[0] = 0; ptr->val[1] = 255; ptr->val[2] = 0; } } // use the row pointer and the image has one channel for (int h = 0; h &lt; image.rows; ++h) { uchar* ptr = image.ptr(h); for (int w = 0; w &lt; image.cols / 2; ++w) { ptr[w] = 128; } } // use the pixel pointer and the image has one channel for (int h = 0; h &lt; image.rows; ++h) { for (int w = 0; w &lt; image.cols / 2; ++w) { uchar* ptr = image.ptr&lt;uchar>(h, w); *ptr = 255; } } iterator // the image has three channels Mat_&lt;Vec3b>::iterator it = image.begin&lt;Vec3b>(); Mat_&lt;Vec3b>::iterator itend = image.end&lt;Vec3b>(); for (; it != itend; ++it) { (*it)[0] = 255; (*it)[1] = 0; (*it)[2] = 0; } // the image has one channel Mat_&lt;uchar>::iterator it1 = image.begin&lt;uchar>(); Mat_&lt;uchar>::iterator itend1 = image.end&lt;uchar>(); for (; it1 != itend1; ++it1) { (*it1) = 128; } .data pointer // 3 channels uchar* data = image.data; for (int h = 0; h &lt; image.rows; ++h) { for (int w = 0; w &lt; image.cols / 2; ++w) { *data++ = 128; *data++ = 128; *data++ = 128; } } // 1 channel uchar* data = image.data; for (int h = 0; h &lt; image.rows; ++h) { for (int w = 0; w &lt; image.cols / 2; ++w) { *data++ = 128; } } .row() and .col() for (int i = 0; i &lt; 100; ++i) { image.row(i).setTo(Scalar(0, 0, 0)); // modify the i th row data image.col(i).setTo(Scalar(0, 0, 0)); // modify the i th column data } when isContinuous() is true Mat image = imread("..."); int nRows = image.rows; int nCols = image.cols * image.channels(); if (image.isContinuous()) { nCols = nRows * nCols; nRows = 1; } for (int h = 0; h &lt; nRows; ++h) { uchar* ptr = image.ptr&lt;uchar>(h); for (int w = 0; w &lt; nCols; ++w) { // ptr[w] = 128 ; *ptr++ = 128; } } Reference http://t.csdn.cn/bSDNn</description></item><item><title>Snippets of OpenVINO-CPP for Model Inference</title><link>https://lartpang.github.io/blog/posts/0022-snippets-of-openvino-cpp-for-model-inference/</link><pubDate>Mon, 25 Mar 2024 09:41:05 +0000</pubDate><guid>https://lartpang.github.io/blog/posts/0022-snippets-of-openvino-cpp-for-model-inference/</guid><description> Snippets of OpenVINO-CPP for Model Inference Header File #include &lt;openvino/openvino.hpp> Create Infer Request void preprocessing(std::shared_ptr&lt;ov::Model> model) { ov::preprocess::PrePostProcessor ppp(model); ppp.input().tensor().set_layout("NHWC"); // input data is NHWC from OpenCV Mat ppp.input().model().set_layout("NCHW"); // In the model, the layout is NCHW model = ppp.build(); } ov::Core core; auto model = core.read_model(model_path); # can use onnx or openvino's xml file preprocessing(model); auto compiled_model = core.compile_model(model, "CPU"); // Or without `"CPU"` auto input_port = compiled_model.input(); auto infer_request = compiled_model.create_infer_request(); Input and Output single input infer_request.set_input_tensor(blob); infer_request.crop_net.infer(); single output ov::Tensor single_output = this->point_net.get_output_tensor(0); multiple outputs ov::Tensor multi_outputs0 = this->point_net.get_output_tensor(0); ov::Tensor multi_outputs1 = this->point_net.get_output_tensor(1); OpenCV cv::Mat &lt;-> OpenVINO ov::Tensor The key to these steps is the alignment of the data layout.</description></item><item><title>Build OpenCV and OpenVINO for Windows 10 with VS 2022</title><link>https://lartpang.github.io/blog/posts/0023-build-opencv-and-openvino-for-windows-10-with-vs-2022/</link><pubDate>Mon, 25 Mar 2024 09:38:03 +0000</pubDate><guid>https://lartpang.github.io/blog/posts/0023-build-opencv-and-openvino-for-windows-10-with-vs-2022/</guid><description> Build OpenCV and OpenVINO for Windows 10 with VS 2022 In this guide, I will build the two powerful open-source libraries, i.e., OpenCV and OpenVINO for running my deeplearning model on windows 10. Interestingly, both libraries are closely associated with Intel üñ•Ô∏è.</description></item></channel></rss>